import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import scipy.interpolate as intp
import robust
import os, pyfits, pdb

class CCD:
    """CCD RIXS image with associated processing and plotting

    Data objects:
    -----------
            CCD.fname_list      List of file names to be read
            CCD.fname_BG        String path to background image
            CCD.exclude         2 element list. Only use columns >exclude[0] & <exclude[1] 
            CCD.raw_images      List of 2D arrays with raw CCD images
            CCD.raw_backgrounds List of 2D arrays with background CCD images
            CCD.images          List of 2D arrays with processed CCD images
            CCD.backgrounds     List of 2D arrays with processed CCD backgrounds
            CCD.specs           List of 1D RIXS spectra
            CCD.BGspecs
                                Each spectrum is [x, y] list of numpy arrays
            CCD.raw_spectrum    Sum of all spectra [x [in pixels], y, e] list of numpy arrays
            CCD.spectrum        Sum of all spectra [x [in energy], y, e] list of numpy arrays
            CCD.correlations    List of correlation functions
 
            CCD.photon_E        Energy of incident photons
            CCD.curvature       polynominal describing curvature
            CCD.poly_order      Order of polynominal describing Curvature
                                order = 3 imples x**0 + x**1 + x**2
            CCD.binpix          Number of pixels to bin together in curvature determination
            
            info_               prefix info denotes stuff related to curvature determination 
            CCD.info_x          Centers of bins for cuvature determination in pixel units
            CCD.info_peaks      Peaks in correlation functions used to get curvature
            CCD.info_corr       correlation function matrix
            CCD.info_shifted    CCD image after shifting by curvature
            CCD.info_ref        The reference spectrum generated by the left hand edge
                                of the image
                                
            CCD.shifts          Numbers of pixels the spectra were shifted in CCD.correlate() 
                                proceedure
                                
    Processes:
    -----------            
            CCD.clean()         remove background and values above threshold
            CCD.plot()          plot CCD image
            CCD.get_curvature() determine curvature
            CCD.get_specs()     bin CCD images into 1D using current curvature
            CCD.correlate()     Shift the pixel/E values overlapp all subsequent 
                                spectra with the first spectrum
            CCD.sum_specs()     sum 1D spectra together into CCD.spectrum
            CCD._gendark        get or generate the dark image
    """ 

    def __init__(self, fname_list=[], photon_E=930., poly_order=3, binpix=8, fileout='test.dat', fname_list_BG =[], exclude=[None, None]):
        """ Initiate class
        loading raw data from list of strings describing filesnames. 
        Various values (defined above) are initiated to
        defaults unless otherwise specified
        """
        self.binpix = binpix
        self.poly_order = poly_order
        self.photon_E = photon_E
        self.fname_list = fname_list
        self.fname_BG = fname_list_BG
        self.exclude = exclude
        self.shifts = []
        self.fileout = fileout
        
        self.raw_images = []
        for fname in fname_list:
            if fname[-4:] == 'fits':
                fitsobj = pyfits.open(fname)
                M = fitsobj[2].data
            else:
                try:
                    self.raw_images.append(plt.imread(fname + '.tif'))
                except IOError:
                    z = zipfile.ZipFile(fname + '.zip')
                    z.extract(z.namelist()[0], path=os.path.dirname(fname))
                    self.raw_images.append(plt.imread(fname + '.tif'))
                    zout = zipfile.ZipFile(fname + '.zip', "w")
                    zout.close()
            self.raw_images.append(M)

        if len(fname_list_BG) == 1:
            fname_list_BG = fname_list_BG * len(fname_list)
        self.raw_backgrounds = []
        for fname_BG in fname_list_BG:
            if fname_BG[-4:] == 'fits':
                fitsobj = pyfits.open(fname_BG)
                M = fitsobj[2].data
            else:
                try:
                    self.raw_backgrounds.append(plt.imread(fname_BG + '.tif'))
                except IOError:
                    z = zipfile.ZipFile(fname_BG + '.zip')
                    z.extract(z.namelist()[0], path=os.path.dirname(fname_BG))
                    self.raw_backgrounds.append(plt.imread(fname_BG + '.tif'))
                    zout = zipfile.ZipFile(fname_BG + '.zip', "w")
                    zout.close()
            self.raw_backgrounds.append(M)
       
        if self.raw_backgrounds == []:
            for M in self.raw_images:
                self.raw_backgrounds.append(self._gen_dark(M))
        
################ PROCESSES FOR DATA ##################
   
    def clean(self, thHIGH):
        """ Remove background and convert from electrons to photons 
        gainregion  = indlow:indhigh defining energy gain rows on array
        e.g. 0:500        
        and set values above thHIGH to 0
        """
        self.images = []
        for image in self.raw_images:
            e_per_ph = self.photon_E /  3.65
            image = image / e_per_ph;
            meanimage = np.mean(image[image < thHIGH])
            image[image > thHIGH] = meanimage
            self.images.append(image)
        
        self.backgrounds = []
        for background in self.raw_backgrounds:
            e_per_ph = self.photon_E /  3.65
            background = background / e_per_ph;
            meanbackground = np.mean(background[background < thHIGH])
            background[background > thHIGH] = meanbackground
            self.backgrounds.append(background)
    
    def sub_backgrounds(self):
        for i in range(len(self.images)):
            self.images[i] = self.images[i] - self.backgrounds[i]

    def get_curvature(self, index=0):
        """ Determine the curvature of the CCD image specified by index
        The data are binned in columns *binpix* pixels wide
        a correlation function is calculated using the central set of pixels
        as a reference. The peaks of each binned column is then fit by a polynominal """
        M = self.images[index]
        #M = M - np.mean(M[0:50, :]) # need to have zeros at the top and bottom 
        #                              of the image 
        x = self.binpix/2 + self.binpix * np.arange(np.floor(np.shape(M)[1]/self.binpix))
        keep = np.all((x> self.exclude[0]+self.binpix/2 , x < self.exclude[1]-self.binpix/2), axis=0)
        x = x[keep]
        
        M_corr = np.zeros((np.shape(M)[0], np.shape(M)[1]/self.binpix))
        peaks = []
        
        cenpix = 0 
        ref = np.sum(M[:,(x[cenpix]-self.binpix):(x[cenpix]+self.binpix)], axis=1)
        for i in range(0, int(np.shape(M)[1]/self.binpix)):
            indices = i*self.binpix + np.array(range(self.binpix))
            curr = np.sum(M[:,indices], axis=1)
            ycorr = np.correlate(curr, ref, mode='same')
            M_corr[:,i] = ycorr
            #print ycorr
            peaks.append(np.argmax(ycorr))
        
        peaks = np.array(peaks) + 0.0
        print peaks
        # exclude values        
        peaks = peaks[keep]
        
        self.curvature = robust.polyfit(x, peaks, self.poly_order, iterMax=25)
        self.info_x = x
        self.info_peaks = peaks
        self.info_corr = M_corr
        self.info_ref = ref
        
    def offset_curvature(self, offset='Find Peak'):
        """ The constant in the curvature defined in self.curvature and self.curvature_info
        is abitrary.  This offsets it. If no argument is given the offset is set to the
        peak in the spectrum"""
        if offset=='Find Peak':
            currentOffset = np.polyval(self.curvature, self.info_x[0])
            currentPeak = np.argmax(self.info_ref)
            offset  = currentPeak - currentOffset
        self.curvature[-1:] += offset
        self.info_peaks += offset
        print "Curvature was offst by %f" %offset

           
###################### BINNING AND SUMMING #################

    def get_specs(self):
        """ Extract the spectra using the predefined curvature"""
        x = np.arange(np.shape(self.images[0])[0])
        p = np.hstack((self.curvature[:-1], 0))
                
        self.specs = []
        M_shifted = np.zeros(np.shape(self.images[0]))  # will be filled with image with columns shifted to cancel the curvature
        for image in self.images:
            for col in range(np.shape(image)[1]):
                M_shifted[:, col] = np.interp(x, x - np.polyval(p, col), image[:, col],
                                           left=np.NaN, right=np.NaN)
            y = np.sum(M_shifted[:,self.exclude[0]:self.exclude[1]], axis=1)
            inds = ~np.logical_or(np.isnan(x), np.isnan(y))
            self.specs.append([x.transpose()[inds], y.transpose()[inds]])
  
        self.info_shifted = M_shifted
    
    def get_BGspecs(self):
        x = np.arange(np.shape(self.backgrounds[0])[0])
        p = np.hstack((self.curvature[:-1], 0))
        
        self.BGspecs = []
        M_shifted = np.zeros(np.shape(self.backgrounds[0]))  # will be filled with image with columns shifted to cancel the curvature
        for background in self.backgrounds:
            for col in range(np.shape(background)[1]):
                M_shifted[:, col] = np.interp(x, x - np.polyval(p, col), background[:, col],
                                           left=np.NaN, right=np.NaN)
            y = np.sum(M_shifted[:,self.exclude[0]:self.exclude[1]], axis=1)
            inds = ~np.logical_or(np.isnan(x), np.isnan(y))
            self.BGspecs.append([x.transpose()[inds], y.transpose()[inds]])


    def correlate_specs(self):
        """ determine x shift referenced to the first spectrum
        x values are shifted by this value"""
        self.shifts.append(0)
        dx = 0.1
        xfine = np.arange(np.min(self.specs[0][0]), np.max(self.specs[0][0]), dx) # 10 times oversampling
        ref = sp.interp(xfine, self.specs[0][0], self.specs[0][1])
        self.correlations = []
        self.correlations.append(sp.correlate(ref, 
                                            ref, mode='full'))
        for i in range(1, len(self.specs)):
            currfine = sp.interp(xfine, self.specs[i][0], self.specs[i][1])
            self.correlations.append(sp.correlate(ref, currfine,  mode='full'))
        for i in range(1, len(self.specs)):
            shift = np.argmax(self.correlations[i]) - np.argmax(self.correlations[0])
            print shift
            shift = shift * dx
            print shift
            print "spectrum %d shifted by %f" % (i, shift)           
            self.specs[i][0] = self.specs[i][0] + shift
            self.shifts.append(shift)

    def sum_specs(self):
        """ Sum the specs into one spectrum.
        Calculating error from standard deviation"""
        x = self.specs[0][0]
        if len(self.specs) == 1:
            y = self.specs[0][1]
            e = y*0.0
        else:
            YY = self.specs[0][1]
            for i in range(1, len(self.specs)):
                funcy = intp.interp1d(self.specs[i][0], self.specs[i][1], kind='linear', 
                            bounds_error=False, fill_value=np.NaN)
                YY = np.column_stack((YY, funcy(x)))
            y = np.sum(YY, axis=1)
            e = np.std(YY, axis=1)
        
        inds = ~np.logical_or(np.isnan(x), np.isnan(y), np.isnan(e)),        
        self.spectrum = [x[inds], y[inds], e[inds]]

    def calibrate(self, elastic_pixel, E_per_pix):
        """ Convert the spectrum into energy by specifying the elastic pixel and
        energy perpixel"""
        self.spectrum[0] = (elastic_pixel - self.spectrum[0]) *  E_per_pix

    def calibrate_poly(self, elastic_pixel, p):
        """ Convert the spectrum into energy by specifying the elastic pixel and
        energy perpixel"""
        self.spectrum[0] = (elastic_pixel - self.spectrum[0]) *  E_per_pix 
        self.spectrum[0] = np.polyv
###################### OUTPUTTING DATA #####################

    def write_file(self):
        """Write text file""" 
        header = "Files\n"
        for fname in self.fname_list:
            header += fname + "\n"
        header += "Curvature " + str(self.curvature) + '\n'
        header += "Shifts" + str(self.shifts) + '\n'
        header += "Exclusion" + str(self.exclude) + '\n'
        header += "########################\n"
        header += "pixel \t phonons \t error \n"
        M = np.column_stack((self.spectrum[0], self.spectrum[1],
                             self.spectrum[2]))
        np.savetxt(self.fileout, M, header=header)

###################### PLOTTING FUNCTIONS #####################

    def plot_curvature(self):
        """ Plot the peaks in the correlation function and the fit defining the 
        curvature
        """
        #x = self.curvature_info[0]
        plt.plot(self.info_x, self.info_peaks, 'b.')
        hoizPixels = np.shape(self.images[0])[1]
        rowofCCD = np.arange(hoizPixels)
        plt.plot(rowofCCD, np.polyval(self.curvature, rowofCCD), 'r-')
    
    def plot_image(self, index = 0, **kwargs):
        """ Plot the specified CCD image, as chosen via index.
        **kwargs are passed to plt.imshow"""
        plt.imshow(self.images[index], vmin=np.percentile(self.images[index],1),
               vmax=np.percentile(self.images[index], 99.999), cmap=plt.cm.Greys_r, aspect='auto', interpolation='none')
        plt.colorbar()
    
    def plot_hist(self, index=0, bins=10, **kwargs):
        """ Plot histrogram specified CCD image, as chosed via index
        bins = the number of bins to be used this function can be used to 
        examine the statistics of the spectrum. **kwargs are pass to plt.hist"""
        plt.hist(self.images[index].ravel(), bins=bins, log=True, **kwargs)
        plt.xlabel('Number of photons')
        plt.ylabel('Number of pixels')
        
    def plot_specs(self, index=[], **kwargs):
        """ Plot all spectra. **kwargs are passed to plt.plot"""
        if index==[]:
            for spec in self.specs:
                plt.plot(spec[0], spec[1], '.-', **kwargs)
        else:
            plt.plot(self.specs[index][0], self.specs[index][1], '.-', **kwargs)

    def plot_backgrounds(self, index=[], **kwargs):
        """ Plot all spectra. **kwargs are passed to plt.plot"""
        if index==[]:
            for BGspec in self.BGspecs:
                plt.plot(BGspec[0], BGspec[1], '.-', **kwargs)
        else:
            plt.plot(self.BGspec[index][0], self.BGspec[index][1], '.-', **kwargs)

    def plot_spectrum(self, offset=0.0, **kwargs):
        """ Plot the summed spectrum using errorbar"""
        plt.errorbar(self.spectrum[0], self.spectrum[1]+ offset,
                     self.spectrum[2], fmt='.-', **kwargs)

################ INTERNATL PROCESSES ##########
    def _gen_dark(self, M):
        """ Generate image for background subtraction without real dark image
        """
        return M*0 + np.percentile(M[200:500,:], 50)